---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# netatmo-weather

<!-- badges: start -->
<!-- badges: end -->

The goal of netatmo-weather is to provide access to Netatmo measurements and station metadata making use of the weather API at dev.netatmo.com.

## Installation

You can install the development version of netatmo-weather from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
# devtools::install_github("falk-env/netatmo-weather")
```

## Getting Started

### Authentication

In order to be able to access data, please follow the subsequent steps carefully:

1) Register a user account at [auth.netatmo.com](https://auth.netatmo.com/access/signup).

2) Login at [dev.netatmo.com](https://auth.netatmo.com/de-de/access/login?next_url=https%3A%2F%2Fdev.netatmo.com%2F).

3) Click on your username in the upper right corner and create a new application. Provide mandatory information (*).

4) Once saved, rename `example-oauth.cfg` in your package directory to e.g. `oauth.cfg` and replace dummy details with data from your own app (app name, client ID, client secret). 

5) Execute the following function in order to create a Oauth 2 token.

```{r}
netatmo.weather::get_oauth2token("oauth.cfg")
```

6) When asked, whether you want to use a local file to cache OAuth access credentials between R sessions, choose 1: Yes.

7) You'll be redirected to your browser to grant access to your application. Accept. Note: `get_oauth2token()` is limited to `"read_station"` scope.

8) Successful authentication is confirmed in your browser: "Authentication complete. Please close this page and return to R.".

9) Your token is stored in the `.httr-oauth` file in your package directory and as `.sig` in your R environment. 

In case you wanted to execute /getpublicdata and /getmeasure API calls from your browser (for debugging reasons or whatever), you'll need to append your access token to your URL ("&access_token=xxx"). You'll also be notified if you try to execute requests with your access token missing.

You can access your access and refresh token consisting of a key and secret making use of little helpers provided:

```
print_at()
#> "&access_token=62361e03ca18e13802546z20|5dt2091f1693dbff35f0428f2386b492"

print_rt()
#> "&refresh_token=62361e03ca18e13802546z20|6ce2fb2490a615d58b16e874fz4eb579"
```

Issued access tokens expire after 3 hours and have to be refreshed again in order to be used. 
Usually, this is performed in the background without the user noticing. However, you could also check and refresh yourself if you'd like:

```
is_expired()
#> TRUE

refresh_at()
#> <Token>
#> <oauth_endpoint>
#>  authorize: https://api.netatmo.net/oauth2/authorize
#>  access:    https://api.netatmo.net/oauth2/token
#> <oauth_app> de_uhi
#>   key:    62361e03ca18e13802546z20
#>   secret: <hidden>
#> <credentials> scope, access_token, expires_in, expire_in, refresh_token

is_expired()
#> FALSE
```

### /getpublicdata

API queries via `get_publicdata()` in order to obtain station metadata require a user-defined bounding box as the main function argument. In order to facilitate this, `get_extent()` was implemented to help you out:

```{r}
# using coordinates (xmin, ymin, xmax, ymax)
e1 <- get_extent(x = c(6.89, 51.34, 7.13, 51.53), epsg = 4326)
e1

# using municipality names
e2 <- get_extent(x = "Essen")
e2

# using postal codes
e3 <- get_extent(x = "45145")
e3
```

This information can now be used to list stations with accordant metadata located in this area (at the time of the query):

```{r}
stations <- get_publicdata(ext = e1)

# returning a simple feature collection with 305 features
stations
```

However, since the number of stations coming from /getpublicdata seems to be influenced by the size of the area queried, the argument `use_tiles` was implemented, slicing your area of interest in tiles à 0.05° to be queried separately in order to ensure the maximum number of available stations.

```{r}
stations_tiled <- get_publicdata(ext = e1, use_tiles = TRUE)

# returning a simple feature collection with 635 features using the same extent as above
stations_tiled
```

### /getmeasure

API queries via `get_measure()` in order to obtain station observations basically require a base station MAC address to be queried (included in `stations`), the parameter to be queried (e.g. `temperature`, `humudity`, `sum_rain`), the measurement interval in minutes (e.g. `5`, `30`, `60`) and a period encompassing the timestamp of the first and last observation to retrieve in form of the local UNIX time in seconds. 

To assist you with the latter going backwards from `Sys.time()`, `get_period()` exists:

```{r}
# per default returning the maximum number of observations (1024) as a function of `res` chosen
# default: `res = 5`
p1a <- get_period()
as.POSIXct(p1a, origin = "1970-01-01")

# hourly data
p1b <- get_period(res = 60)
as.POSIXct(p1b, origin = "1970-01-01")

# querying the last 24 hours, maybe convenient for scheduled jobs
p2 <- get_period(x = "recent")
as.POSIXct(p2, origin = "1970-01-01")

# self-defined period
p3 <- get_period(x = c("2022-06-01", "2022-06-04"))
as.POSIXct(p3, origin = "1970-01-01")
```

This can now be used to acquire observations of previously identified stations in form of listed `xts` objects (might take some time to execute):

```{r}
# get data
obs_temperature <- get_measure(devices = stations_tiled, par = "temperature", res = 60, period = "recent")

class(obs_temperature)
length(obs_temperature)

# subset to individual xts object
xts <- obs_temperature[[1]]

head(xts)

plot(xts, col = "red")

# inspect appended metadata
attributes(xts)
```
